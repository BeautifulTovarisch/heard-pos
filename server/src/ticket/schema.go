// schema.go
//
// Representation and database operations of a kitchen order.
//
package ticket

import (
	"fmt"
	"os"
	"time"

	"github.com/jmoiron/sqlx"
)

type Ticket struct {
	Id          int64
	Server      string
	OrderNumber int8 `db:"order_no"`
	TableNumber int8 `db:"table_no"`

	Opened time.Time
	Closed time.Time
}

const Schema = `
CREATE TABLE IF NOT EXISTS ticket (
	id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	server varchar(255) NOT NULL,
	order_no integer NOT NULL DEFAULT 1,
	table_no integer NOT NULL,

	opened timestamp WITH TIME ZONE DEFAULT NOW(),
	closed timestamp WITH TIME ZONE CHECK (opened < closed)
);
`

// Increment orders #s within a 24 hour period
// This avoids outrageous order numbers having to be read by the expediter
// TODO :: Consider calculating based on the last order number in a time period
var create_ticket = `
INSERT INTO ticket(server, table_no, order_no)
SELECT :server, :table_no, count(id) + 1
	FROM ticket
	WHERE ticket.opened <= current_timestamp + interval '1 day'
	AND ticket.opened >= current_timestamp - interval '1 day'
RETURNING id;
`

// We increment order # based on total number of tickets since opening
func Insert(conn *sqlx.DB, ticket Ticket) int64 {
	var id int64
	// Need to use NamedQuery due to the fact that LastInsertId() not supported
	rows, err := conn.NamedQuery(create_ticket, ticket)
	defer rows.Close()

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error inserting ticket %v\n", err)
	}

	for rows.Next() {
		err := rows.Scan(&id)

		if err != nil {
			fmt.Fprintf(os.Stderr, "Error retrieving inserted ticket id: %v", err)
		}
	}

	return id
}
